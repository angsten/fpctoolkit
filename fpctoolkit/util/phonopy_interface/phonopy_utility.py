#import fpctoolkit.util.phonopy_interface.phonopy_utility as phonopy_utility

import numpy as np

from phonopy import Phonopy
from phonopy.interface.vasp import read_vasp, write_vasp
from phonopy.interface.vasp import parse_set_of_forces
from phonopy.file_IO import parse_FORCE_SETS, write_FORCE_CONSTANTS, parse_BORN
from phonopy.structure.symmetry import Symmetry

from fpctoolkit.structure.structure import Structure
from fpctoolkit.util.path import Path
from fpctoolkit.io.file import File
import fpctoolkit.util.misc as misc

def convert_structure_to_phonopy_atoms(structure, temporary_write_path):
	"""
	Takes structure, a Structure instance, and returns a PhonopyAtoms class (phonopy's representation of structures)

	temporary_write_path is where the structure is temporarily written to for purposes of conversion. This should be a safe
	path that won't overwrite other items. This path is deleted at the end.
	"""

	Structure.validate(structure)

	Path.validate_does_not_exist(temporary_write_path)
	Path.validate_writeable(temporary_write_path)

	structure.to_poscar_file_path(temporary_write_path)
	phonopy_structure = read_vasp(temporary_write_path)

	Path.remove(temporary_write_path)

	return phonopy_structure


def get_initialized_phononopy_instance(initial_structure, phonopy_inputs, temporary_directory_path):
	"""
	Initializes and returns a valid Phonopy instance and with displacements internally generated
	"""

	unit_cell_phonopy_structure = phonopy_utility.convert_structure_to_phonopy_atoms(initial_structure, Path.join(temporary_directory_path, "tmp_initial_phonon_structure_POSCAR"))
	supercell_dimensions_matrix = np.diag(phonopy_inputs['supercell_dimensions'])

	phonon = Phonopy(unitcell=unit_cell_phonopy_structure, supercell_matrix=supercell_dimensions_matrix, symprec=phonopy_inputs['symprec'])
	phonon.generate_displacements(distance=phonopy_inputs['displacement_distance'])

	return phonon


def convert_phonopy_atoms_to_structure(phonopy_atoms_structure, species_list, temporary_write_path):
	"""
	Converts phonopy's representation of a structure to an instance of Structure.

	temporary_write_path is where the phonopy atoms structure is temporarily written to for purposes of conversion. This should be a safe
	path that won't overwrite other items. This path is deleted at the end.
	"""

	Path.validate_does_not_exist(temporary_write_path)
	Path.validate_writeable(temporary_write_path)

	write_vasp(temporary_write_path, phonopy_atoms_structure)

	structure_poscar_file = File(temporary_write_path)
	structure_poscar_file.insert(5, " ".join(species_list)) #phonopy uses bad poscar format
	structure_poscar_file.write_to_path()

	final_structure = Structure(temporary_write_path)

	Path.remove(temporary_write_path)

	Structure.validate(final_structure)

	return final_structure


def get_distorted_structures_list(initial_structure, phonopy_inputs, temporary_directory_path):
	"""
	Returns the list of distorted structures generated by phonopy necessary for a phonon calculation.
	phonopy_inputs should be a dictionary that looks like:

	phonopy_inputs_dictionary = {
		'supercell_dimensions': [2, 2, 2],
		'symprec': 0.001,
		'displacement_distance': 0.01,
		'nac': True
		...
	}
	"""

	phonon = get_initialized_phononopy_instance(initial_structure, phonopy_inputs, temporary_directory_path)

	####temp code#####
	symmetry = phonon.get_symmetry()
	print "Space group of initial primitive structure:", symmetry.get_international_table()
	####

	supercells = phonon.get_supercells_with_displacements()

	distorted_structures_list = []
	for i in range(len(supercells)):
		distorted_structure = phonopy_utility.convert_phonopy_atoms_to_structure(supercells[i], initial_structure.get_species_list(), Path.join(temporary_directory_path, 'tmp_distorted_structure'))
		distorted_structures_list.append(distorted_structure)

	return distorted_structures_list


def write_force_constants_to_file_path(initial_structure, phonopy_inputs, temporary_directory_path, vasp_xml_file_paths_list, file_path):
	"""
	Writes the phonopy-calculated force constants to file_path
	"""

	phonon = get_initialized_phononopy_instance(initial_structure, phonopy_inputs, temporary_directory_path)



	sets_of_forces = parse_set_of_forces(num_atoms=get_supercell_atom_count(initial_structure, phonopy_inputs), forces_filenames=vasp_xml_file_paths_list)

	phonon.produce_force_constants(sets_of_forces)

	write_FORCE_CONSTANTS(phonon.get_force_constants(), filename=file_path)


def write_born_file(initial_structure, phonopy_inputs, temporary_directory_path, dielectric_tensor, born_effective_charge_tensor, file_path):
	"""
	Creates the born file that phonopy needs for the non-analytical correction to be applied.
	"""

	phonon = get_initialized_phononopy_instance(initial_structure, phonopy_inputs, temporary_directory_path)


	symm = Symmetry(cell=phonon.get_primitive(), symprec=phonopy_inputs['symprec'])

	independent_atom_indices_list = symm.get_independent_atoms()


	born_file = File()

	born_file += "14.400"

	flat_dielectric_list = misc.flatten_multi_dimensional_list(dielectric_tensor)

	born_file += " ".join(str(component) for component in flat_dielectric_list)


	for atomic_bec_index in independent_atom_indices_list:
		atomic_bec = born_effective_charge_tensor[atomic_bec_index]

		flat_atomic_bec = misc.flatten_multi_dimensional_list(atomic_bec)

		born_file += " ".join(str(component) for component in flat_atomic_bec)

	born_file.write_to_path(file_path)



def get_supercell_atom_count(initial_structure, phonopy_inputs):
	"""
	Returns the number of atoms in the supercell representation of initial structure. This is also the number of atoms in each of the static force calculations.
	"""

	return reduce(lambda x, y: x*y, phonopy_inputs['supercell_dimensions'], initial_structure.site_count)