#import fpctoolkit.util.phonopy_interface.phonopy_utility as phonopy_utility

import numpy as np

from phonopy import Phonopy
from phonopy.interface.vasp import read_vasp, write_vasp
from phonopy.interface.vasp import parse_set_of_forces
from phonopy.file_IO import parse_FORCE_SETS, parse_FORCE_CONSTANTS, write_FORCE_CONSTANTS, parse_BORN
from phonopy.structure.symmetry import Symmetry

from fpctoolkit.structure.structure import Structure
from fpctoolkit.util.path import Path
from fpctoolkit.io.file import File
import fpctoolkit.util.misc as misc
import fpctoolkit.util.string_util as su



def get_initialized_phononopy_instance(initial_structure, phonopy_inputs, force_constants_path=None, born_path=None):
	"""
	Initializes and returns a valid Phonopy instance and with displacements internally generated.

	If force_constants_path is specified, the phonopy instance is initialized with the force constants at the given path.
	If the born_path is specified, the born file at this path is used to initialize the nac parameters of the phonopy instance, but
	only if the nac key has a value of true in the phonopy_inputs dictionary.

	phonopy_inputs should be a dictionary that looks like:

	phonopy_inputs_dictionary = {
		'supercell_dimensions': [2, 2, 2],
		'symprec': 0.001,
		'displacement_distance': 0.01,
		'nac': True
		...
	}
	"""

	unit_cell_phonopy_structure = convert_structure_to_phonopy_atoms(initial_structure)
	supercell_dimensions_matrix = np.diag(phonopy_inputs['supercell_dimensions'])

	phonon = Phonopy(unitcell=unit_cell_phonopy_structure, supercell_matrix=supercell_dimensions_matrix, symprec=phonopy_inputs['symprec'])
	phonon.generate_displacements(distance=phonopy_inputs['displacement_distance'])


	if force_constants_path != None:
		force_constants = parse_FORCE_CONSTANTS(filename=force_constants_path)
		phonon.set_force_constants(force_constants)


	if born_path != None and (phonopy_inputs.has_key('nac') and phonopy_inputs['nac']):
		nac_params = parse_BORN(phonon.get_primitive(), filename=born_path)
		phonon.set_nac_params(nac_params)

	return phonon


def convert_structure_to_phonopy_atoms(structure):
	"""
	Takes structure, a Structure instance, and returns a PhonopyAtoms class (phonopy's representation of structures)
	"""

	temporary_write_path = Path.get_temporary_path()

	Structure.validate(structure)

	Path.validate_does_not_exist(temporary_write_path)
	Path.validate_writeable(temporary_write_path)

	structure.to_poscar_file_path(temporary_write_path)
	phonopy_structure = read_vasp(temporary_write_path)

	Path.remove(temporary_write_path)

	return phonopy_structure


def convert_phonopy_atoms_to_structure(phonopy_atoms_structure, species_list):
	"""
	Converts phonopy's representation of a structure to an instance of Structure.
	"""

	temporary_write_path = Path.get_temporary_path()

	Path.validate_does_not_exist(temporary_write_path)
	Path.validate_writeable(temporary_write_path)

	write_vasp(temporary_write_path, phonopy_atoms_structure)

	structure_poscar_file = File(temporary_write_path)
	structure_poscar_file.insert(5, " ".join(species_list)) #phonopy uses bad poscar format
	structure_poscar_file.write_to_path()

	final_structure = Structure(temporary_write_path)

	Path.remove(temporary_write_path)

	Structure.validate(final_structure)

	return final_structure


def get_distorted_structures_list(initial_structure, phonopy_inputs):
	"""
	Returns the list of distorted structures generated by phonopy necessary for a phonon calculation.
	"""

	phonon = get_initialized_phononopy_instance(initial_structure, phonopy_inputs)

	####temp code#####
	symmetry = phonon.get_symmetry()
	print "Space group of initial primitive structure:", symmetry.get_international_table()
	####

	supercells = phonon.get_supercells_with_displacements()

	distorted_structures_list = []
	for i in range(len(supercells)):
		distorted_structure = convert_phonopy_atoms_to_structure(supercells[i], initial_structure.get_species_list())
		distorted_structures_list.append(distorted_structure)

	return distorted_structures_list


def write_force_constants_to_file_path(initial_structure, phonopy_inputs, vasp_xml_file_paths_list, file_path):
	"""
	Writes the phonopy-calculated force constants to file_path
	"""

	phonon = get_initialized_phononopy_instance(initial_structure, phonopy_inputs)



	sets_of_forces = parse_set_of_forces(num_atoms=get_supercell_atom_count(initial_structure, phonopy_inputs), forces_filenames=vasp_xml_file_paths_list)

	phonon.produce_force_constants(sets_of_forces)

	write_FORCE_CONSTANTS(phonon.get_force_constants(), filename=file_path)


def write_born_file(initial_structure, phonopy_inputs, dielectric_tensor, born_effective_charge_tensor, file_path):
	"""
	Creates the born file that phonopy needs for the non-analytical correction to be applied.
	"""

	phonon = get_initialized_phononopy_instance(initial_structure, phonopy_inputs)


	symm = Symmetry(cell=phonon.get_primitive(), symprec=phonopy_inputs['symprec'])

	independent_atom_indices_list = symm.get_independent_atoms()


	born_file = File()

	born_file += "14.400"

	flat_dielectric_list = misc.flatten_multi_dimensional_list(dielectric_tensor)

	born_file += " ".join(str(component) for component in flat_dielectric_list)


	print "Independent atom indices:", independent_atom_indices_list

	for atomic_bec_index in independent_atom_indices_list:
		atomic_bec = born_effective_charge_tensor[atomic_bec_index]

		flat_atomic_bec = misc.flatten_multi_dimensional_list(atomic_bec)

		born_file += " ".join(str(component) for component in flat_atomic_bec)

	born_file.write_to_path(file_path)



def get_supercell_atom_count(initial_structure, phonopy_inputs):
	"""
	Returns the number of atoms in the supercell representation of initial structure. This is also the number of atoms in each of the static force calculations.
	"""

	return reduce(lambda x, y: x*y, phonopy_inputs['supercell_dimensions'], initial_structure.site_count)









def view_eigen_values_and_eigen_vectors(phonopy_instance, q_points_list):
	"""
	phonopy_instance is an initialized instance of the Phonopy class
	q_points list is list of q_points in reduced coordinates, like [[0.5, 0.0, 0.0], [0.25, 0.25, 0.3], ...]
	"""

	primitive_cell = phonopy_instance.get_primitive()

	for q_point in q_points_list:
		data = phonopy_instance.get_frequencies_with_eigenvectors(q_point)

		eigen_values = data[0]
		eigen_vectors = data[1]

		qstr = "Q-point: " + str(q_point).rstrip()
		
		print "-"*90 + " " + qstr + " " + "-"*90

		



		for band in range(len(eigen_values)):
			eigen_value = eigen_values[band]
			eigen_vector = eigen_vectors[band]

			bnd_str = "-"*40 + "Band index: " + str(band+1) + "-"*40

			print "Frequency: " + str(round(eigen_value, 5)) + '\n'

			for i in range(len(eigen_vector)/3):

				f = su.pad_decimal_number_to_fixed_character_length
				rnd = 4
				padding_length = 10
				sep = "   "
				string = "Atom " + str(i) + sep + str(f(eigen_vector[3*i].real, rnd, padding_length)) + sep + str(f(eigen_vector[3*i+1].real, rnd, padding_length)) + sep + str(f(eigen_vector[3*i+2].real, rnd, padding_length)) 
				string += sep*2 + str(f(eigen_vector[3*i].imag, rnd, padding_length)) + sep + str(f(eigen_vector[3*i+1].imag, rnd, padding_length)) + sep + str(f(eigen_vector[3*i+2].imag, rnd, padding_length))

				print string

			print "-"*len(bnd_str) + '\n'*1


		print "-"*200 + '\n'*2